Техническое задание
Настало время улучшить Filmorate. Чтобы составлять рейтинг фильмов, нужны отзывы пользователей. А для улучшения
рекомендаций по просмотру хорошо бы объединить пользователей в комьюнити.
По итогам прошлого спринта у вас получилась заготовка приложения. Программа может принимать, обновлять и возвращать
пользователей и фильмы. В этот раз улучшим API приложения до соответствия REST, а также изменим архитектуру приложения с
помощью внедрения зависимостей.
Наводим порядок в репозитории
Для начала убедитесь в том, что ваши изменения за предыдущий спринт добавлены в ветку main. Создайте новую ветку,
которая будет называться add-friends-likes. Название ветки важно сохранить, потому что оно влияет на запуск тестов в
GitHub.

Подсказка: про работу в Git
Для слияния веток используйте команду merge.
Архитектура
Начнём с переработки архитектуры. Сейчас вся логика приложения спрятана в контроллерах — изменим это. Вынесите хранение
данных о фильмах и пользователях в отдельные классы. Назовём их хранилищами (англ. storage) — так будет сразу понятно,
что они делают.

    Создайте интерфейсы FilmStorage и UserStorage, в которых будут определены методы добавления, удаления и модификации объектов.
    Создайте классы InMemoryFilmStorage и InMemoryUserStorage, имплементирующие новые интерфейсы, и перенесите туда 
    всю логику хранения, обновления и поиска объектов.
    Добавьте к InMemoryFilmStorage и InMemoryUserStorage аннотацию @Component, чтобы впоследствии пользоваться 
    внедрением зависимостей и передавать хранилища сервисам.

Подсказка: про структуру проекта
Чтобы объединить хранилища, создайте новый пакет storage. В нём будут только классы и интерфейсы, имеющие отношение к
хранению данных. Например, ru.yandex.filmorate.storage.film.FilmStorage.
Новая логика
Пока у приложения нет никакой бизнес-логики, кроме валидации сущностей. Обеспечим возможность пользователям добавлять
друг друга в друзья и ставить фильмам лайки.

    Создайте UserService, который будет отвечать за такие операции с пользователями, как добавление в друзья, удаление 
    из друзей, вывод списка общих друзей. Пока пользователям не надо одобрять заявки в друзья — добавляем сразу. То есть
    если Лена стала другом Саши, то это значит, что Саша теперь друг Лены.
    Создайте FilmService, который будет отвечать за операции с фильмами — добавление и удаление лайка, вывод 1010 
    наиболее популярных фильмов по количеству лайков. Пока пусть каждый пользователь может поставить лайк фильму только 
    один раз.
    Добавьте к ним аннотацию @Service — тогда к ним можно будет получить доступ из контроллера.

Подсказка: ещё про структуру
По аналогии с хранилищами объедините бизнес-логику в пакет service.

Подсказка: про список друзей и лайки
Есть много способов хранить информацию о том, что два пользователя являются друзьями. Например, можно создать свойство
friends в классе пользователя, которое будет содержать список его друзей. Вы можете использовать такое решение или
придумать своё.
Чтобы обеспечить уникальность значения (нельзя добавить одного человека в друзья дважды), проще всего использовать для
хранения Set<Long> c id друзей. Таким же образом можно обеспечить условие «один пользователь — один лайк» для оценки
фильмов.
Зависимости
Переделайте код в контроллерах, сервисах и хранилищах под использование внедрения зависимостей.

    Используйте аннотации @Service, @Component, @Autowired. Внедряйте зависимости через конструкторы классов.
    Классы-сервисы должны иметь доступ к классам-хранилищам. Убедитесь, что сервисы зависят от интерфейсов 
    классов-хранилищ, а не их реализаций. Таким образом в будущем будет проще добавлять и использовать новые реализации 
    с другим типом хранения данных.
    Сервисы должны быть внедрены в соответствующие контроллеры.

Подсказка: @Service vs @Component
@Component — аннотация, которая определяет класс как управляемый Spring. Такой класс будет добавлен в контекст
приложения при сканировании. @Service не отличается по поведению, но обозначает более узкий спектр классов — такие,
которые содержат в себе бизнес-логику и, как правило, не хранят состояние.
Полный REST
Дальше стоит заняться контроллерами и довести API до соответствия REST.

    С помощью аннотации @PathVariable добавьте возможность получать каждый фильм и данные о пользователях по их 
    уникальному идентификатору: GET .../users/{id}.
    Добавьте методы, позволяющие пользователям добавлять друг друга в друзья, получать список общих друзей и лайкать 
    фильмы. Проверьте, что все они работают корректно.
      
        PUT /users/{id}/friends/{friendId}  — добавление в друзья.
        DELETE /users/{id}/friends/{friendId} — удаление из друзей.
        GET /users/{id}/friends — возвращаем список пользователей, являющихся его друзьями.
        GET /users/{id}/friends/common/{otherId} — список друзей, общих с другим пользователем.
        PUT /films/{id}/like/{userId}  — пользователь ставит лайк фильму.
        DELETE /films/{id}/like/{userId}  — пользователь удаляет лайк.
        GET /films/popular?count={count} — возвращает список из первых count фильмов по количеству лайков. Если значение
    параметра count не задано, верните первые 1010.
    Убедитесь, что ваше приложение возвращает корректные HTTP-коды:
      
        400400 — если ошибка валидации: ValidationException;
        404404 — для всех ситуаций, если искомый объект не найден;
        500500 — если возникло исключение.

Подсказка
НастройтеExceptionHandler для централизованной обработки ошибок.
Дополнительное логирование
Разработка любого приложения не застрахована от ошибок. Синтаксические ошибки поможет обнаружить компилятор, а вот
логические обнаружить намного сложнее.
В процессе проектирования и написания кода приложения учтите места, в которых будет разумно добавить отладочные
сообщения. Это поможет разобраться с возможными ошибками и другими проявлениями некорректной реализации.
Также подключите к проекту дополнительный стартер:

<dependency>
    <groupId>org.zalando</groupId>
    <artifactId>logbook-spring-boot-starter</artifactId>
    <version>3.7.2</version>
</dependency> 

Этот стартер интегрирует в Spring Framework библиотеку Logbook. Она будет выводить в лог информацию об HTTP-запросах и
ответах.
Кроме подключения внешней зависимости, нужно настроить уровень логера, который ответственен за вывод деталей об
HTTP-сообщениях. Для этого добавьте в конфигурационный файл следующее свойство:

logging.level.org.zalando.logbook: TRACE

Теперь библиотека будет выводить в лог информацию о деталях запроса и ответа в формате JSON.

Подробнее о том, как будет выглядеть вывод с Logbook
Пример вывода:

2024-04-05T12:38:04.538+03:00 TRACE 6562 --- [nio-8080-exec-2] org.zalando.logbook.Logbook              : {"origin":"
remote","type":"request","correlation":"a20d8031dc76768d","protocol":"HTTP/1.1","remote":"0:0:0:0:0:0:0:1","method":"
POST","
uri":"http://localhost:8080/users","host":"localhost","path":"/users","scheme":"http","port":"8080","headers":{"accept":["*/*"],"accept-encoding":["gzip,
deflate, br"],"cache-control":["no-cache"],"connection":["keep-alive"],"content-length":["143"],"
content-type":["application/json"],"host":["localhost:8080"],"postman-token":["ae7d451b-ad84-4862-92f1-196c6908cdf0"],"
user-agent":["PostmanRuntime/7.37.0"]},"body":{"email":"vasilii.pupkin@practicum.ru","name":"Василий Пупкин","login":"
pumpkin","birthday":"1986-08-20"}}
2024-04-05T12:38:04.646+03:00 TRACE 6562 --- [nio-8080-exec-2] org.zalando.logbook.Logbook              : {"origin":"
local","type":"response","correlation":"a20d8031dc76768d","duration":137,"protocol":"HTTP/1.1","status":200,"headers":{"
Connection":["keep-alive"],"Content-Type":["application/json"],"Date":["Fri, 05 Apr 2024 09:38:04 GMT"],"
Keep-Alive":["timeout=60"],"Transfer-Encoding":["chunked"]},"body":{"id":1,"email":"vasilii.pupkin@practicum.ru","
login":"pumpkin","name":"Василий Пупкин","birthday":"1986-08-20"}}

Основные поля:

    в type находится тип лога — request для запроса или response для ответа;
    в headers — заголовки запроса/ответа;
    в body — тело запроса/ответа.

Входящий запрос:

    в method — HTTP-метод запроса;
    в uri — URI запроса, по которому был вызван метод;
    в path — путь запроса.

Ответ:

    в duration — время продолжительности ответа (в миллисекундах);
    в status — HTTP-статус ответа.